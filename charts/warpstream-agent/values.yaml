image:
  repository: "public.ecr.aws/warpstream-labs/warpstream_agent"
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

revisionHistoryLimit: 10

replicas: 3

deploymentStrategy:
  type: RollingUpdate

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Specifies whether a service token should be mounted on pod
  automountServiceAccountToken: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  # name: ""

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # runAsNonRoot: true

service:
  type: ClusterIP
  port: 9092
  httpPort: 8080

rbac:
  create: true

headlessService:
  enabled: true

config:
  playground: false
  ## To learn what values to set for the config variables, look at our documentation
  ## for configuring the WarpStream Agents for production.
  ## https://docs.warpstream.com/warpstream/how-to/configure-the-warpstream-agent-for-production
  # bucketURL: "mem://mem_bucket"
  # apiKey: "YOUR_API_KEY"
  # virtualClusterID: "YOUR_VIRTUAL_CLUSTER_ID"
  # region: "us-east-1"

resources:
  # Recommendations:
  #   1. At least 2 requests vCPUs per Agent, and only use whole numbers for CPUs
  #      because we set GOMAXPROCS to the value of requested CPUs.
  #      The Agents use the value of GOMAXPROCS to determine how many cores they have,
  #      (to avoid throttling) and size caches and other data structures in accordance
  #      with the number of available cores (which is assumed to scale linearly with
  #      the amount of available ram with a ratio of at least 4GiB of RAM per vCPU.
  #      Setting GOMAXPROCS lower than the number of requested CPUs would prevent
  #      the Agents from utilizing all of the available resources. Setting the value
  #      higher may lead to OOMs as the Agents try to use more RAM than they actually
  #      have available.
  #   2. At least 4GiB of RAM per vCPU.
  #   3. Run on dedicated network optimized instances (m6in class in AWS) for high volume
  #      use-cases.
  #   4. Keep memory requests and limits the same.
  requests:
    cpu: 2
    memory: 8Gi
  limits:
    memory: 8Gi

extraEnv: []
# Add additional environment settings to the pod. Can be useful in proxy
# environments

extraArgs: []
# Add additional args settings to the pod.

nodeSelector: {}

tolerations: []

affinity: {}

topologySpreadConstraints: []

priorityClassName: ""

# Optional horizontal pod autoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPU: "60"
  targetMemory: ""
  behavior: {}

# never use together with horizontal autoscaling
verticalAutoscaling:
  enabled: false
  # Recommender responsible for generating recommendation for the object.
  # List should be empty (then the default recommender will generate the recommendation)
  # or contain exactly one recommender.
  # recommenders:
  # - name: custom-recommender-performance

  # -- List of resources that the vertical pod autoscaler can control. Defaults to cpu and memory
  controlledResources: []

  # Specifies which resource values should be controlled: RequestsOnly or RequestsAndLimits.
  # controlledValues: RequestsAndLimits

  # -- Defines the max allowed resources for the pod
  maxAllowed: {}
  # cpu: 200m
  # memory: 100Mi
  # -- Defines the min allowed resources for the pod
  minAllowed: {}
  # cpu: 200m
  # memory: 100Mi

  # updatePolicy:
    # Specifies minimal number of replicas which need to be alive for VPA Updater to attempt pod eviction
    # minReplicas: 1
    # Specifies whether recommended updates are applied when a Pod is started and whether recommended updates
    # are applied during the life of a Pod. Possible values are "Off", "Initial", "Recreate", and "Auto".
    # updateMode: Auto

# Optional disruption budget
pdb:
  create: false
  # apiVersion: ""
  # minimum number of pods that must still be available after the eviction (both integers and percentages are supported)
  minAvailable: "50%"
  # maximum number of pods that can be unavailable after the eviction (both integers and percentages are supported)
  maxUnavailable: 1

serviceMonitor:
  ## If true, a ServiceMonitor CRD is created for a prometheus operator
  ## https://github.com/coreos/prometheus-operator
  ##
  enabled: false
  path: /metrics
  labels: {}
  interval: 30s
  scheme: http
  tlsConfig: {}
  scrapeTimeout: 30s
  relabelings: []
  metricRelabelings: []
  targetLabels: []
  honorLabels: true

prometheusRule:
  ## If true, a PrometheusRule CRD is created for a prometheus operator
  ## https://github.com/coreos/prometheus-operator
  ##
  enabled: false
  labels: {}
  groups:
    - name: groupName
      rules:
      - alert: alertName
        expr: 'alert expression'
        for: 5m
        labels:
          severity: high
        annotations:
          identifier: 'Alert identifier.'
          msg: Alert message.

## list of hosts and IPs that will be injected into the pod's hosts file
hostAliases: []
  # - ip: "127.0.0.1"
  #   hostnames:
  #   - "foo.local"
  #   - "bar.local"

# Labels to be added to each agent pod
podLabels: {}

# Optional initContainers definition
initContainers: []
